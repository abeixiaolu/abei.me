---
title: 实现一个 Mini Vite
description: 学习｜vite｜源码｜源码解析
date: 2025-02-25
series: true
---

> Wip...

这是一个系列文章，主要面对那些想了解 vite 基础原理的读者。当然，其实更多的是记录我自己的学习过程，如有错误，欢迎指正～

## Vite 设计理念

Vite 是基于浏览器原生支持 ES Modules 的特性，让浏览器接管了传统打包工具的部分职责。传统的打包工具在开发时，需要先进行 bundle 的过程，然后浏览器才能进行模块的解析和执行；而 vite 只需要在浏览器请求模块时进行转换并按需返回模块内容即可，针对依赖，vite 会先进行预构建，并缓存到 `node_modules/.vite` 目录下，然后浏览器在请求时即可直接读取构建产物。并且源码模块会根据 `304 Not Modified` 进行协商缓存，而依赖模块请求则会通过 `Cache-Control:max-age=31536000,immutable` 进行强缓存，一旦模块被缓存过后将不会需要重新请求。

### 依赖预构建

1. 原因：
   1. 统一格式，cjs 和 umd 到 esm 模块。
   2. 性能：将有许多内部 esm 模块的依赖项转为单个模块
2. 缓存处理：
   1. 预构建依赖使用强缓存
   2. 源码模块使用协商缓存
3. 裸模块导入转换

### 与 webpack 的对比

#### HMR

webpack 需要维护一个模块图，当某个文件变化时，需要重新构建整个模块图。而且在某些情况下（模块的依赖链发生变化、HMR 边界失效等）它仍然需要重新构建整个应用。而 vite 不需要维护模块图，当某个文件变化时，只需要使该模块及其最近的 HMR 边界之间的依赖链失活，而不需要重新构建整个应用。总结一下：

1. vite 基于 ESM 无需构建依赖图
2. 天然支持按需加载模块
3. 只处理需要模块，不会受到应用规模的影响

#### 生产构建

webpack 开发环境和生产环境的构建方式相同。vite 则不同：尽管原生 ESM 现已得到广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，vite 使用 Rollup 打包（tree-shaking、懒加载和 chunk 分割），并使用 esbuild （插件 API 不兼容）预构建依赖。之后会切换为 Rolldown （Rollup 的继任者，但是使用 rust 重写）。

vite 的生产构建优化

1. **css 代码分割**：异步加载的模块，它所加载的 css 也会被单独打包成一个模块。
2. **预加载指令生成**：为入口 chunk 和 HTML 中直接引入自动生成的 `<link rel="modulepreload">` 指令。
3. **异步 chunk 加载优化**：vite 会扫描所有异步 chunk 并找到他们之间的共同依赖，并打包为一个单独的文件，减少网络请求嵌套和模块被重复加载的问题。
